// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.8.6;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IMasset {
    function mint(address, uint256, uint256, address) external returns (uint256);
    function redeem(address, uint256, uint256, address) external returns (uint256);
    function redeemExactBassets(address[] memory, uint256[] memory, uint256, address) external;
    function getRedeemExactBassetsOutput(address[] memory, uint256[] memory) external view returns (uint256);
}

contract MockERC677WithdrawExploitor {
    address public masset = address(0);
    address public tokenA = address(0);
    address public tokenB = address(0);

    uint256 private amount = 1000 * (10 ** 6);

    constructor(address _masset, address _tokenA, address _tokenB) {
        masset = _masset;
        tokenA = _tokenA;
        tokenB = _tokenB;
    }

    function depositFunds() public {
        IERC20(tokenA).approve(address(masset), type(uint256).max);

        IMasset(masset).mint(address(tokenA), amount, 0, address(this));
    }
    
    function withdrawFunds() public {
        IERC20(masset).approve(masset, type(uint256).max);

        IMasset(masset).redeem(tokenA, amount, 0, address(this));
    }

    function withdrawFundsMulti() public {
        IERC20(masset).approve(masset, type(uint256).max);

        address[] memory tokens = new address[](2);
        tokens[0] = tokenA;
        tokens[1] = tokenB;

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = amount / 2;
        amounts[1] = amount / 2;

        uint256 maxMassetQuantity = IMasset(masset).getRedeemExactBassetsOutput(tokens, amounts);

        IMasset(masset).redeemExactBassets(
            tokens, 
            amounts, 
            maxMassetQuantity, 
            address(this)
        );
    }

    function onTokenTransfer(address _from, uint256 _value, bytes memory _data) external returns (bool) {
        withdrawFunds();
        return true;
    }
}
